# 확장 기능

---

## 사용자 정의 리포지토리 구현

+ 스프링 데이터 JPA 리포지토리는 인터페이스만 정의하고 구현체는 스프링이 자등으로 생성
+ 인터페이스의 메서드를 직접 구현하고 싶을 때
  + JPA 직접 사용 (`EntityManager`)
  + 스프링 JDBC Template 
  + MyBatis
  + 데이터베이스 커넥션 
  + Querydsl
---


사용자 정의 인터페이스

```java
public interface MemberRepositoryCustom {

    List<Member> findMemberCustom();
}
```


사용자 정의 인터페이스 구현 클래스

```java
@RequiredArgsConstructor
public class MemberRepositoryImpl implements MemberRepositoryCustom{

    private final EntityManager em;

    @Override
    public List<Member> findMemberCustom() {
        return em.createQuery("select m from Member m")
                .getResultList();
    }
}
```

사용자 정의 인터페이스 사용

```java
public interface MemberRepository extends JpaRepository<Member,Long>, MemberRepositoryCustom{}
```

### 사용자 정의 구현 클래스 규칙

리포지토리 인터페이스 이름 + `Impl`


최근에는 `사용자 정의 인터페이스 이름` + `Impl`도 지원한다.

```java
public class MemberRepositoryCustomImpl implements MemberRepositoryCustom {
    private final EntityManager em;
    @Override
    public List<Member> findMemberCustom() {
        return em.createQuery("select m from Member m")
                .getResultList();
    }
}
```

기존의 방식보다 인터페이스 이름과 구현 클래스 이름이 비슷하므로 더 직관적으로 알 수 있다.

> 항상 사용자 정의 리포지토리가 필요한 것은 아니다. 임의의 리포지토리 클래스를 만들어서 사용해도 된다. 

---

## Auditing

엔티티를 생성하거나 변경할 때 변경한 사람과 시간을 추적하는 방법

+ 등록일
+ 수정일
+ 등록자
+ 수정자

---

### 순수 JPA 사용

```java
@Getter
@MappedSuperclass
public class JpaBaseEntity {

    @Column(updatable = false)
    private LocalDateTime createdDate;

    private LocalDateTime updatedDate;

    @PrePersist
    public void prePersist(){
        LocalDateTime now = LocalDateTime.now();
        this.createdDate = now;
        this.updatedDate = now;
    }

    @PreUpdate
    public void preUpdate(){
        updatedDate = LocalDateTime.now();
    }
}
```

```java
public class Member extends JpaBaseEntity{}
```

---

## 스프링 데이터 JPA 사용

`@EnableJpaAuditing` 스프링 부트 설정 클래스에 적용

`@EntityListeners(AuditingEntityListener.class)` 엔티티 적용


```java
@EnableJpaAuditing
@SpringBootApplication
public class DataJpaApplication {

  public static void main(String[] args) {
    SpringApplication.run(DataJpaApplication.class, args);
  }
  
  @Bean
  public AuditorAware<String> auditorProvider(){
    return new AuditorAware<String>() {
      @Override
      public Optional<String> getCurrentAuditor() {
        return Optional.of(UUID.randomUUID().toString());
      }
    };
  }
}
```

```java
@EntityListeners(AuditingEntityListener.class)
@MappedSuperclass
@Getter
public class BaseEntity extends BaseTimeEntity{

  @CreatedBy
  @Column(updatable = false)
  private String createdBy;

  @LastModifiedBy
  private String lastModifiedBy;
}
```

```java
@EntityListeners(AuditingEntityListener.class)
@MappedSuperclass
@Getter
public class BaseTimeEntity {

    @CreatedDate
    @Column(updatable = false)
    private LocalDateTime createdDate;

    @LastModifiedDate
    private LocalDateTime lastModifiedDate;
}
```

```java
public class Member extends BaseEntity{}
```

실무에서는 등록시간, 수정시간이 필요하지만, 등록자 수정자는 필요 없을 수도 있다.

Base 타입을 분리하고, 원하는 타입을 선택해서 상속하면 된다.


