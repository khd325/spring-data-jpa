# 쿼리 메소드 기능

+ 메소드 이름으로 쿼리 생성
+ NamedQuery
+ @Query - 리포지토리 메소드에 쿼리 정의
+ 파라미터 바인딩
+ 반환 타입
+ 페이징과 정렬
+ 벌크성 수정 쿼리
+ @EntityGraph

---

## 메소드 이름으로 쿼리 생성

---

```text
em.createQuery("select m from Member m where m.username = :username and m.age > :age")
                .setParameter("username",username)
                .setParameter("age",age)
                .getResultList();
                
순수 JPA로 작성한 쿼리를 스프링 데이터 JPA로 사용하면 한 줄이면 된다.

List<Member> findByUsernameAndAgeGreaterThan(String username,int age);
```
[스프링 데이터 JPA가 제공하는 쿼리 메소드 기능](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repositories.query-methods.query-creation)

이 기능은 엔티티의 필드명이 변경되면 인터페이스에서 정의한 메서드 이름도 함께 변경해야 한다.

---

## JPA NamedQuery

실무에선 별로 사용하지 않음

---

```java
@NamedQuery(
        name="Member.findByUsername",
        query="select m from Member m where m.username = :username"
)
public class Member {}
```

```text

 //리포지토리
 public List<Member> findByUsername(String username){
        return em.createNamedQuery("Member.findByUsername",Member.class)
                .setParameter("username",username)
                .getResultList();
 }
   
------------------------------------------------------------------------------
//테스트 코드
List<Member> result = memberJpaRepository.findByUsername("AAA");
```

```text
/*@Query(name = "Member.findByUsername") //생략가능*/
List<Member> findByUsername(@Param("username") String username);

------------------------------------------------------------------------------

List<Member> result = memberRepository.findByUsername("AAA");
```

`@Query` 애노테이션을 생략하고 메서드 이름만으로 호출이 가능하다.

스프링 데이터 JPA는 선언한 `도메인 클래스` + `.` + `메서드 이름`으로 Named 쿼리를 찾기 때문에 호출 가능

만약 Named 쿼리가 없으면 `메서드 이름으로 쿼리 생성 전략`을 사용한다.

> 실무에선 Named Query를 직접 등록해서 사용하는 일이 드물고 `@Query`를 사용해서 리포지토리 메서드에 쿼리를 직접 정의한다.


---

## @Query, 리포지토레 메서드에 쿼리 정의

---

```text

//리포지토리
@Query("select m from Member m where m.username = :username and m.age = :age")
List<Member> findUser(@Param("username") String username,@Param("age") int age);

------------------------------------------------------------------------------
//테스트 코드
List<Member> result = memberRepository.findUser("AAA", 10);
```

`@Query`를 사용하여 리포지토리의 메서드에 직접 정의할 수 있다. 

애플리케이션 실행시점에 문법 오류를 발견할 수 있기 때문에 매우 큰 강점을 갖고 있다.

> 실무에서 메서드 이름으로 쿼리 생성 기능을 사용하면 파라미터가 증가하면 메서드 이름이 매우 지저분해지기 때문에 `@Query` 기능을 자주 사용한다.


---

## @Query: 값, DTO 조회하기

---

```java
@Data
public class MemberDto {

    private Long id;
    private String username;
    private String teamName;

    public MemberDto(Long id, String username, String teamName) {
        this.id = id;
        this.username = username;
        this.teamName = teamName;
    }
}
```

```text
@Query("select new study.datajpa.dto.MemberDto(m.id,m.username,t.name) from Member m join m.team t")
List<MemberDto> findMemberDto();
```

DTO로 직접 조회하기 위해서는 `new` 키워드를 사용해야 하고 생성자에 맞는 DTO가 필요하다.

---

## 파라미터 바인딩

+ 위치 기반
+ 이름 기반

```sql
select m from Member m where m.username =?0
select m from Member m where m.username = :name
```

---

### 컬렉션 파라미터 바인딩

```text
@Query("select m from Member m where m.username in :names")
List<Member> findByNames(@Param("names") Collection<String> names);


-------------------------------------------------------------------------
List<Member> result = memberRepository.findByNames(Arrays.asList("AAA", "BBB"));

-------------------------------------------------------------------------

select member0_.member_id as member_i1_0_, member0_.age as age2_0_, member0_.team_id as team_id4_0_, member0_.username as username3_0_ from member member0_ where member0_.username in ('AAA' , 'BBB');
```

---

## 반환 타입

```java
List<Member> findByUsername(String name); //컬렉션
Member findByUsername(String name); //단건
Optional<Member> findByUsername(String name); //단건 Optional
```

스프링 데이터 JPA는 단건 조회 시 JPQL의 `getSingleResult()`을 호출한다. 이 때 결과가 없으면 `NoResultException` 예외가 발생하는 대신 `null`을 반환한다.

단건 조회 시 2개 이상이면 똑같이 `NonUniqueResultException`이 발생한다.

---

## 순수 JPA 페이징과 정렬

---

+ 검색 조건: 나이가 10살
+ 정렬 조건: 이름으로 내림차순
+ 페이징 조건: 첫 번째 페이지, 페이지당 보여줄 데이터는 3건

---


```java
@Repository
public class MemberJpaRepository {

    @PersistenceContext
    private EntityManager em;

    public Member save(Member member){
        em.persist(member);
        return member;
    }

    public List<Member> findByPage(int age, int offset, int limit){
        return em.createQuery("select m from Member m where m.age = :age order by m.username desc")
                .setParameter("age",age)
                .setFirstResult(offset)
                .setMaxResults(limit)
                .getResultList();
    }

    public long totalCount(int age){
        return em.createQuery("select count(m) from Member m where m.age = :age", Long.class)
                .setParameter("age",age)
                .getSingleResult();
    }
}
```

```java
    @Test
    public void paging() {
        memberJpaRepository.save(new Member("member1", 10));
        memberJpaRepository.save(new Member("member2", 10));
        memberJpaRepository.save(new Member("member3", 10));
        memberJpaRepository.save(new Member("member4", 10));
        memberJpaRepository.save(new Member("member5", 10));

        int age = 10;
        int offset = 0;
        int limit = 3;

        List<Member> members = memberJpaRepository.findByPage(age, offset, limit);
        long totalCount = memberJpaRepository.totalCount(age);

        assertThat(members.size()).isEqualTo(3);
        assertThat(totalCount).isEqualTo(5);
    }
```

---
